:	This is a shell archive.
:	Remove everything above this line and
:	run the following text with /bin/sh to create:
:	README
:	_dyn_tree.h
:	dyn_splay.c
:	dyn_tree.c
:	dyn_tree.h
:	macros.h
:	makefile
: This archive created: Sun May 26 21:41:31 1991
echo shar: extracting README
sed 's/^XX//' << 'SHAR_EOF' > README
XX Dynamic tree data structure operations
XX
XX   Based on Sleator, Tarjan : Self-Adjusting Binary Search Trees
XX   JACM Vol. 32., No. 3, July 1985 pp.652-686 
XX   
XX   Slight difference: The Real roots have only middle children,
XX   so that infinite value on the root can be handled.
XX
XX   Implemented by 
XX   Tamas Badics, 1991, 
XX   Rutgers University, RUTCOR
XX   P.O.Box 5062
XX   New Brunswick, NJ, 08901
XX 
XX  e-mail: badics@rutcor.rutgers.edu
XX
XX/**********************************************************
XX  Usage of the dynamic tree routines:
XX
XX  The main purpose of using this data structure is to deal with
XX  trees of any type of objects with a value associated with them. 
XX  See the literature! (linking-cutting trees)
XX  
XX  The user need only the dyn_tree.h header file and the object
XX  files which can be created with the enclosed makefile.
XX  All the other sourcefiles could be referred to as a black box.
XX
XX  So the first step is to make the objects with gcc.
XX  (type make dyn_tree)
XX  
XX  After this you can use the functions described in dyn_tree.h
XX***********************************************************  
XX
XX  If you find this program useful and worth to work with,
XX  or if you have any questions, suggestions or bugs found,
XX  please write it to me and I am happy to answer.
XX  
XX  Tamas Badics, 1991
SHAR_EOF
if test 1293 -ne "`wc -c README`"
then
echo shar: error transmitting README '(should have been 1293 characters)'
fi
echo shar: extracting _dyn_tree.h
sed 's/^XX//' << 'SHAR_EOF' > _dyn_tree.h
XX/* _dyn_tree.h == local type and function definitions*/
XX/*
XX   Implemented by 
XX   Tamas Badics, 1991, 
XX   Rutgers University, RUTCOR
XX   P.O.Box 5062
XX   New Brunswick, NJ, 08901
XX 
XX  e-mail: badics@rutcor.rutgers.edu
XX*/
XX
XX#ifndef _DYN_T
XX#define _DYN_T
XX
XX#include "dyn_tree.h"
XX
XX#define dmg  (g->dmin)
XX#define dmf  (f->dmin)
XX#define dmh (ch->dmin)
XX#define dmr	 (r->dmin)
XX#define dmm	 (m->dmin)
XX#define dma	 (a->dmin)
XX#define dmb	 (b->dmin)
XX#define dmc	 (c->dmin)
XX#define dmd	 (d->dmin)
XX#define dml	 (l->dmin)
XX
XX#define dvg  (g->dval)
XX#define dvf  (f->dval)
XX#define dvh (ch->dval)
XX#define dvr	 (r->dval)
XX#define dvm	 (m->dval)
XX#define dva	 (a->dval)
XX#define dvb	 (b->dval)
XX#define dvc	 (c->dval)
XX#define dvd	 (d->dval)
XX#define dvl	 (l->dval)
XX
XXtypedef struct DYN_NODE{
XX	dyn_item		* item;
XX	struct DYN_NODE	* left, * right, * father;
XX	DOUBLE            dmin;
XX	DOUBLE            dval;
XX}dyn_node;
XX
XX
XXdyn_node * dyn_splay(dyn_node * child ); /* Brings up the child in its virtual 
XX											tree. After this procedure child will
XX											be a middle-child of The Root.
XX											Returns the pointer to child.*/
XX
XXvoid dyn_splay_solid(dyn_node * child );   /* Brings up the child in its 
XX											  solid subtree. After this 
XX											  procedure child will be the 
XX											  root of the solid tree*/
XX
XXvoid splice(dyn_node * m);   /* m is a solid root, middle-child 
XX								of its f, who is also a solid root.
XX								Change m to be the left-child. 
XX								(the old left-child will be a middle)*/
XX
XX#endif
XX
SHAR_EOF
if test 1501 -ne "`wc -c _dyn_tree.h`"
then
echo shar: error transmitting _dyn_tree.h '(should have been 1501 characters)'
fi
echo shar: extracting dyn_splay.c
sed 's/^XX//' << 'SHAR_EOF' > dyn_splay.c
XX/* dyn_splay.c ==== rotate subroutines for the splay step in dynamic tree 
XX   data structure */
XX/*
XX   Implemented by 
XX   Tamas Badics, 1991, 
XX   Rutgers University, RUTCOR
XX   P.O.Box 5062
XX   New Brunswick, NJ, 08901
XX 
XX  e-mail: badics@rutcor.rutgers.edu
XX*/
XX
XX#include <stdio.h>
XX#include "_dyn_tree.h"
XX#include "macros.h"
XX
XX/*==========================================================================*/
XXstatic void __dyn_step_r( dyn_node * f, dyn_node * ch)
XX{
XX	DOUBLE tmp;
XX	dyn_node * b, * c, *chf;
XX	
XX	b = ch->left;
XX	c = f->left;
XX	
XX	if( NULL != (f->right = b) )
XX	  b->father = f;
XX	ch->left = f;
XX	
XX	chf = ch->father = f->father;
XX	if( chf->right == f)
XX	  chf->right = ch;
XX	else if(chf->left == f)
XX	  chf->left = ch;
XX	
XX	f->father = ch;
XX	
XX	/* Value update: */
XX	
XX	tmp = dvh;
XX	if (b)
XX	  dvb += tmp;
XX	dmh = tmp + dmf;
XX	dvh += dvf;
XX	dvf = -tmp;
XX	dmf = MAX3( 0, (b ? dmb - dvb : 0), (c ? dmc - dvc : 0));
XX}
XX
XX/*==========================================================================*/
XXstatic void __dyn_step_l( dyn_node	* f, dyn_node * ch)
XX{
XX	DOUBLE tmp;
XX	dyn_node * b, * c, * chf;
XX	
XX	b = ch->right;
XX	c = f->right;
XX	
XX	if(NULL != (f->left = b) )
XX	  b->father = f;
XX	ch->right = f;
XX	
XX	chf = ch->father = f->father;
XX	if( chf->left == f)
XX	  chf->left = ch;
XX	else if(chf->right == f)
XX	  chf->right = ch;
XX	
XX	f->father = ch;
XX	
XX	/* Value update: */
XX	
XX	tmp = dvh;
XX	if (b)
XX	  dvb += tmp;
XX	dmh = tmp + dmf;
XX	dvh += dvf;
XX	dvf = -tmp;
XX	dmf = MAX3( 0, (b ? dmb - dvb : 0), (c ? dmc - dvc : 0));
XX}
XX
XX/*==========================================================================*/
XXstatic void __dyn_step_rl(dyn_node * g, dyn_node * f, dyn_node * ch)
XX{
XX	DOUBLE tmp;
XX	dyn_node * a, * b, * c, * d, * chf;
XX	
XX	a = f->right;
XX	b = ch->right;
XX	c = ch->left;
XX	d = g->left;
XX	
XX	if( NULL != (g->right = c))
XX	  g->right->father = g;
XX	
XX	if (NULL != (f->left = b))
XX	  f->left->father = f;
XX	ch->left	 = g;
XX	ch->right	 = f;
XX	chf = ch->father = g->father;
XX	
XX	if( chf->right == g)
XX	  chf->right = ch;
XX	else if(chf->left == g)
XX	  chf->left = ch;
XX	
XX	g->father = f->father = ch;
XX	
XX	/*======== Value update: ========*/
XX	
XX	tmp = dvh + dvf;
XX	if (b)
XX	  dvb += dvh;
XX	if (c)
XX	  dvc += tmp;
XX	dvf  = -dvh;
XX	dvh = tmp + dvg;
XX	dvg  = -tmp;
XX	dmh = dmg + tmp;
XX	dmg = MAX3( 0, (d ? dmd - dvd : 0), (c ? dmc - dvc : 0));
XX	dmf = MAX3( 0, (a ? dma - dva : 0), (b ? dmb - dvb : 0));
XX}
XX
XX/*==========================================================================*/
XXstatic void __dyn_step_lr(dyn_node * g, dyn_node * f, dyn_node * ch)
XX{
XX	DOUBLE tmp;
XX	dyn_node * a, * b, * c, * d, * chf;
XX	
XX	a = f->left;
XX	b = ch->left;
XX	c = ch->right;
XX	d = g->right;
XX	
XX	if (NULL != (g->left = c) )
XX	  g->left->father = g;
XX	if( NULL != (f->right = b) )
XX	  f->right->father = f;
XX	ch->right	 = g;
XX	ch->left	 = f;
XX	chf = ch->father = g->father;
XX	
XX	if( chf->right == g)
XX	  chf->right = ch;
XX	else if(chf->left == g)
XX	  chf->left = ch;
XX	
XX	g->father = f->father = ch;
XX	
XX	/*======== Value update: ========*/
XX	
XX	tmp = dvh + dvf;
XX	if (b)
XX	  dvb += dvh;
XX	if (c)
XX	  dvc += tmp;
XX	dvf  = -dvh;
XX	dvh = tmp + dvg;
XX	dvg  = -tmp;
XX	dmh = dmg + tmp;
XX	dmg = MAX3( 0, (d ? dmd - dvd : 0), (c ? dmc - dvc : 0));
XX	dmf = MAX3( 0, (a ? dma - dva : 0), (b ? dmb - dvb : 0));
XX	
XX}
XX
XX/*==========================================================================*/
XXstatic void __dyn_step_rr( dyn_node * g, dyn_node * f, dyn_node * ch)
XX{
XX	DOUBLE tmp, tmp1;
XX	dyn_node * b, * c, * d, * chf;
XX	
XX	b = ch->left;
XX	c = f->left;
XX	d = g->left;
XX	
XX	if( NULL != (g->right = c) )
XX	  g->right->father = g;
XX	f->left	 = g;
XX	if( NULL != (f->right = b))
XX	  f->right->father = f;
XX	ch->left = f;
XX	chf = ch->father = g->father;
XX	
XX	if( chf->right == g)
XX	  chf->right = ch;
XX	else if(chf->left == g)
XX	  chf->left = ch;
XX	ch->father	 = g->father;
XX	
XX	g->father = f;
XX	f->father = ch;
XX	
XX	/*======== Value update: ========*/
XX	
XX	if (b)
XX	  dvb += dvh;
XX	if (c)
XX	  dvc += dvf;
XX	tmp = dvh + dvf;
XX	dmh = tmp + dmg;
XX	dmg = MAX3( 0, (c ? dmc - dvc : 0), (d ? dmd - dvd : 0));
XX	dmf = MAX3( 0, (b ? dmb - dvb : 0), dvf + dmg);
XX	tmp1 = -dvh;
XX	dvh = tmp + dvg;
XX	dvg = -dvf;
XX	dvf = tmp1;
XX}
XX
XX/*==========================================================================*/
XXstatic void __dyn_step_ll( dyn_node * g, dyn_node * f, dyn_node * ch)
XX{
XX	DOUBLE tmp, tmp1;
XX	dyn_node * b, * c, * d, * chf;
XX	
XX	b = ch->right;
XX	c = f->right;
XX	d = g->right;
XX	
XX	if( NULL != (g->left = c) )
XX	  g->left->father = g;
XX	f->right	 = g;
XX	if (NULL != (f->left = b) )
XX	  f->left->father = f;
XX	ch->right	 = f;
XX	chf = ch->father = g->father;
XX	
XX	if( chf->right == g)
XX	  chf->right = ch;
XX	else if(chf->left == g)
XX	  chf->left = ch;
XX	ch->father	 = g->father;
XX	
XX	g->father = f;
XX	f->father = ch;
XX	
XX	/*======== Value update: ========*/
XX	
XX	if (b)
XX	  dvb += dvh;
XX	if (c)
XX	  dvc += dvf;
XX	tmp = dvh + dvf;
XX	dmh = tmp + dmg;
XX	dmg = MAX3( 0, (c ? dmc - dvc : 0), ( d ? dmd - dvd : 0));
XX	dmf = MAX3( 0, (b ? dmb - dvb : 0), dvf + dmg);
XX	tmp1 = -dvh;
XX	dvh = tmp + dvg;
XX	dvg = -dvf;
XX	dvf = tmp1;
XX}
XX
XX/*==========================================================================*/
XXvoid splice(dyn_node * m)   /* m is a solid root, middle-child 
XX							   of its f, who is also a solid root.
XX							   Change m to be the left-child. 
XX							   (the old left-child will be a middle)*/
XX{
XX	dyn_node * f = m->father;
XX	dyn_node * l = f->left;
XX	dyn_node * r = f->right;
XX	
XX	f->left = m;  /* Changing the solid edge f-l to f-m */
XX	
XX	/* Here comes the value update */
XX	
XX	dvm -= dvf;
XX	if (l)
XX	  dvl += dvf;
XX	dmf = MAX3( 0,(r ? dmr - dvr : 0), dmm - dvm);
XX}
XX
XX/*==========================================================================*/
XXvoid dyn_splay_solid(dyn_node * ch )	  /* Brings up the ch in its 
XX											 solid subtree. After this 
XX											 procedure ch will be the 
XX											 root of the solid tree.
XX											 
XX											 ch cannot be The Root!*/
XX	 
XX{
XX	dyn_node * g ;
XX	dyn_node * f ;
XX	for(;;){
XX		f = ch->father;
XX		g = f->father;
XX		
XX		if (f->left == ch){
XX			if (g->left == f)
XX			  __dyn_step_ll(g, f, ch);
XX			else if (g->right == f)
XX			  __dyn_step_rl(g, f, ch);
XX			else
XX			  __dyn_step_l(f, ch);
XX		}else if (f->right == ch){
XX			if (g->left == f)
XX			  __dyn_step_lr(g, f, ch);
XX			else if (g->right == f)
XX			  __dyn_step_rr(g, f, ch);
XX			else
XX			  __dyn_step_r(f, ch);
XX		}else
XX		  break;
XX	}
XX}
XX/*==========================================================================*/
XX
XXdyn_node * dyn_splay(dyn_node * ch )	 /* Brings up the ch in its virtual 
XX											tree. After this procedure, ch 
XX											will be a mid-child of the root 
XX											of the virtual tree*/	 
XX{
XX	dyn_node * f;
XX	
XX	
XX	if (ch->father == NULL)   /* If ch is The Root */
XX	  return ch;
XX	
XX	dyn_splay_solid(ch);
XX	
XX	while ((f = ch->father)->father){  /* While f is not The Root */
XX		
XX		dyn_splay_solid(f);	  /* After this, ch is a middle-child 
XX								 of its f, and f is
XX								 a solid root */
XX		splice(ch);
XX		__dyn_step_l(f, ch);
XX	}
XX	return (ch);
XX}
SHAR_EOF
if test 6814 -ne "`wc -c dyn_splay.c`"
then
echo shar: error transmitting dyn_splay.c '(should have been 6814 characters)'
fi
echo shar: extracting dyn_tree.c
sed 's/^XX//' << 'SHAR_EOF' > dyn_tree.c
XX/* dyn_tree.c == Dynamic tree routines, see dyn_tree.h */
XX/*
XX   Implemented by 
XX   Tamas Badics, 1991, 
XX   Rutgers University, RUTCOR
XX   P.O.Box 5062
XX   New Brunswick, NJ, 08901
XX 
XX  e-mail: badics@rutcor.rutgers.edu
XX*/
XX
XX#include "_dyn_tree.h"
XX#include "dyn_tree.h"
XX#include "macros.h"
XX#include <stdio.h>
XX
XX
XX/*==================================================================*/
XXvoid dyn_make_tree(dyn_item * item, DOUBLE value)  
XX	                                     /* Put item to a new 1-node
XX											tree with value. */
XX{
XX	dyn_node * node;
XX	
XX	node = (dyn_node *)malloc(sizeof(dyn_node));
XX
XX	item->back = node;
XX	node->item = item;
XX
XX	node->father = node->left = node->right = NULL;
XX
XX	node->dval = value;
XX	node->dmin = 0;
XX}
XX/*==================================================================*/
XXvoid dyn_link(dyn_item * oldroot, dyn_item * newfather
XX			  , DOUBLE new_value)  
XX	                               /* Hang the tree rooted in oldroot
XX									  to newfather. Must be in 
XX									  different trees! */
XX{
XX	dyn_node * or =oldroot->back;
XX	dyn_node * nf =newfather->back;
XX
XX	if (or->father)
XX	  return;
XX
XX	dyn_splay(nf);
XX
XX	if (nf->father == or){
XX		printf("Error in dyn_link: Both in the same tree!\n");
XX		return;
XX
XX		exit(1);
XX	}
XX	or->father = nf;	
XX	or->dval = new_value;
XX	or->dmin = 0;
XX}
XX/*==================================================================*/
XXvoid dyn_cut(dyn_item * cuthere)   /* Cut the tree between cuthere 
XX									  and its father */
XX
XX{
XX	dyn_node * r, * c, * l;
XX
XX	if ((c = cuthere->back)->father == NULL)
XX	  return;
XX
XX	dyn_splay(c);
XX
XX	if ((r = c->right)){
XX		r->father = c->father;
XX		c->right = NULL;
XX		dvr += dvc;
XX	}
XX	if ((l = c->left)){
XX		c->left = NULL;
XX		dvl += dvc;
XX	}
XX	c->father = NULL;
XX	dmc = 0;
XX}
XX
XX/*==================================================================*/
XXdyn_item * dyn_find_root( dyn_item * item) 
XX	                                /* Find the root of item's tree */
XX
XX{
XX	dyn_node * r = item->back;
XX	
XX	return( r->father ? dyn_splay(r)->father->item : item);
XX}
XX
XX/*==================================================================*/
XXvoid dyn_add_value(dyn_item * from, DOUBLE value)  
XX                                         /* Add value to each node 
XX											on the path from 'from' 
XX											to the root */
XX{
XX	dyn_node * m, * r, * f = from->back;
XX
XX	dyn_splay(f);
XX
XX	dmf = MAX2( 0, (r = f->right) ? dmr - dvr : 0);
XX	if ((m = f->left)){
XX		dvf += value;
XX		dvm -= value;
XX		dmf = MAX2( dmf, dmm - dvm);
XX	}else
XX	  dvf += value;
XX}
XX
XX/*==========================================================*/
XXDOUBLE dyn_find_value(dyn_item * item)   /* Find the value of item */
XX
XX{
XX	dyn_node * n = item->back;
XX	
XX	dyn_splay( n);
XX	return( n->dval);
XX}
XX
XX/*==========================================================*/
XXdyn_item * dyn_find_bottleneck(dyn_item * from, DOUBLE neck)
XX                                /* Find the bottleneck on the path 
XX								   from 'from' to its root. That is
XX								   return the nearest ancestor of
XX								   'from', whose value is <= neck.
XX								   Otherwise return the root. */
XX{
XX	int i;
XX	dyn_node * f, * c, * l;  /* f == from
XX								c == candidate
XX								l == c->left
XX								*/
XX
XX	DOUBLE valc;
XX
XX	f = from->back;
XX
XX	if ( f->father == NULL)              /* from is The Root. */
XX	  return from;             
XX
XX	dyn_splay(f);
XX
XX	if (dvf - dmf > neck)
XX	  return (f->father->item);          /* No bottleneck */
XX
XX	if (dvf <= neck)
XX	  return (from);                     /* from is the bottleneck */
XX
XX	if ( (c = f->right) == NULL || (valc = dvf + dvc) - dmc > neck)
XX	  return (f->father->item);          /* No bottleneck */
XX
XX	/* There is a bottleneck in the right subtree of f 
XX	   (rooted with c) */
XX
XX	l = c->left;
XX	while (( i = (l ? valc + dvl - dml <= neck : 0)) || valc > neck){ 
XX		if (i)
XX		  c = l;
XX		else
XX		  c = c->right;
XX
XX		  valc += dvc;
XX	}
XX
XX	return (dyn_splay(c)->item);
XX}
XX/*==================================================================*/
XXdyn_item * dyn_find_father(dyn_item * item)
XX{
XX	dyn_node * n = item->back;
XX	dyn_node * r;
XX
XX	if (n->father == NULL)
XX	  return NULL;
XX	
XX	dyn_splay_solid(n);
XX
XX	if (r = n->right){
XX		while (r->left)
XX		  r = r->left;
XX		return r->item;
XX	}else
XX	  return (n->father->item);
XX}
SHAR_EOF
if test 4174 -ne "`wc -c dyn_tree.c`"
then
echo shar: error transmitting dyn_tree.c '(should have been 4174 characters)'
fi
echo shar: extracting dyn_tree.h
sed 's/^XX//' << 'SHAR_EOF' > dyn_tree.h
XX/* dyn_tree.h == Dynamic tree data structure type definitions 
XX
XX   Based on Sleator, Tarjan : Self-Adjusting Binary Search Trees
XX   JACM Vol. 32., No. 3, July 1985 pp.652-686 
XX   
XX   Slight difference: The Real roots have only middle children,
XX   so that infinite value on the root can be handled */
XX/*
XX   Implemented by 
XX   Tamas Badics, 1991, 
XX   Rutgers University, RUTCOR
XX   P.O.Box 5062
XX   New Brunswick, NJ, 08901
XX 
XX  e-mail: badics@rutcor.rutgers.edu
XX*/
XX
XX#ifndef DYN_T
XX#define DYN_T
XX
XX/*********************************************************
XX  Usage of the dynamic tree routines:
XX
XX  The main purpose of using this data structure is to deal with
XX  trees of any type of objects with a value associated with them. 
XX  See the literature! (linking-cutting trees)
XX  
XX  The user need only the dyn_tree.h header file and the object
XX  files which can be created with the enclosed makefile.
XX  All the other sourcefiles could be referred to as a black box.
XX
XX  So the only requirement from the objects is to be linkable
XX  into a dynamic tree. Hence the objects (which are naturally 
XX  structures) have to be a member which is a void pointer.
XX
XX  In fact the object is connected through this void pointer to
XX  the dynamic_tree node (which has another pointer pointing
XX  back to the dyn_item, and created by dyn_make_tree).
XX  This allowes to convert a pointer to the object into a pointer
XX  to dyn_item. 
XX
XX  For example:
XX  typedef structure OBJECT {
XX     anything                 \
XX	 .                         >  with length offset 
XX	 .                        /
XX	 void * dyn_point;
XX	 .
XX	 .
XX	 .
XX  }object;
XX  
XX  object * objptr;
XX
XX  It is wiser to place our "void * dyn_point" into the first field
XX  of the structure, but not necessary.
XX  And the dynamic_tree functions can be called as follows:
XX
XX  dyn_make_tree((dyn_item *)((int)(objptr) + offset), value);   
XX
XX  and so on.
XX
XX  If offset == 0 then our objptr can be converted directly.
XX  dyn_make_tree((dyn_item *)(objptr), value);  
XX
XX  And similarly careful returnvalue handling is necessary.
XX  If offset == 0 then objptr can be identified with a dyn_item * 
XX  type pointer from the dynamic tree routins' point of view.
XX
XX  The DOUBLE type is a macro, which can be changed to int or float or
XX  any number type under the compilation from the command line or
XX  from the makefile.
XX
XX*******************************************************************/
XX
XX#ifndef DOUBLE
XX#define DOUBLE double
XX#endif
XX
XXtypedef struct DYN_ITEM{
XX	void * back;
XX}dyn_item;
XX
XXvoid dyn_make_tree(dyn_item * item, DOUBLE value);
XX                                        /* Put item to a new 1-node
XX										   tree with value */
XX
XXvoid dyn_link(dyn_item * oldroot, dyn_item * newfather, DOUBLE new_value);
XX                                        /* Hang the tree rooted in oldroot
XX										   to newfather with new_value. 
XX										   Must be in different trees! */
XX
XXvoid dyn_cut(dyn_item * cuthere);       /* Cut the tree between cuthere 
XX										   and its father */
XX
XXvoid dyn_add_value(dyn_item * from, DOUBLE value);    
XX                                        /* Add value to each node 
XX										   on the path from 'from' 
XX										   to the root */
XX
XXDOUBLE dyn_find_value(dyn_item * item); /* Find the value of item */
XX
XXdyn_item * dyn_find_bottleneck(dyn_item * from, DOUBLE neck);
XX                                        /* Find the bottleneck on the path 
XX										   from 'from' to its root. That is
XX										   return the nearest ancestor of
XX										   'from', whose value is <= neck. */
XX
XXdyn_item * dyn_find_root(dyn_item * item);
XX                                        /* Find the root of item's tree */
XX
XXdyn_item * din_find_father(dyn_item * item);
XX                                        /* Find the father in the tree */
XX
XX#endif
XX
XX
SHAR_EOF
if test 3765 -ne "`wc -c dyn_tree.h`"
then
echo shar: error transmitting dyn_tree.h '(should have been 3765 characters)'
fi
echo shar: extracting macros.h
sed 's/^XX//' << 'SHAR_EOF' > macros.h
XX/* These are some useful macro-declarations */
XX
XX
XX#ifndef MYLIB_
XX#define MYLIB_
XX
XX#define MIN3(A,B,C) (((A)<(B)) ? (((A)<(C))?(A):(C)):(((B)<(C))?(B):(C)))
XX
XX#define MIN2(A,B) (((A)<(B))?(A):(B))
XX
XX#define MAX3(A,B,C) (((A)>(B)) ? (((A)>(C))?(A):(C)):(((B)>(C))?(B):(C)))
XX
XX#define MAX2(A,B) (((A)>(B))?(A):(B))
XX
XX#define sgn(A)  (((A) > 0) ? 1 : ((A)== 0) ? 0 : -1)
XX
XX#endif
XX
SHAR_EOF
if test 370 -ne "`wc -c macros.h`"
then
echo shar: error transmitting macros.h '(should have been 370 characters)'
fi
echo shar: extracting makefile
sed 's/^XX//' << 'SHAR_EOF' > makefile
XX
XXSOURCES= dyn_splay.c dyn_tree.c
XX
XXOBJS= $(CFILES1:%.c=%.o)
XX
XXCC= gcc
XX
XXCFLAGS=-O -c -D"DOUBLE int"  
XX
XXdyn_tree: ${OBJS} 
XX	${CC} ${CFLAGS} ${SOURCES}
XX
XX
XXdyn_splay.o: _dyn_tree.h dyn_tree.h
XXdyn_tree.o:  _dyn_tree.h dyn_tree.h
XX
SHAR_EOF
if test 222 -ne "`wc -c makefile`"
then
echo shar: error transmitting makefile '(should have been 222 characters)'
fi
:	End of shell archive
exit 0
